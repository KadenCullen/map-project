<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Wood Map AR</title>
<style>
  :root { color-scheme: dark; }
  html,body{margin:0;height:100%;background:#0b0d10;color:#e7eaee;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  #hud{position:fixed;inset:0;pointer-events:none}
  #stats{position:fixed;left:10px;bottom:10px;background:#1118;padding:8px 10px;border:1px solid #1b2028;border-radius:10px;font-size:12px}
  #msg{position:fixed;top:10px;left:50%;transform:translateX(-50%);background:#1118;padding:8px 10px;border:1px solid #1b2028;border-radius:10px;font-size:12px;max-width:92vw;white-space:pre-wrap}
  #pins{position:absolute;inset:0;pointer-events:none}

  /* Pins: dot + label + preview */
  .pin{position:absolute;transform:translate(-50%,-50%);pointer-events:auto;will-change:left,top,transform}
  .pin .stack{display:flex;flex-direction:column;align-items:center;gap:2px}
  .pin-dot{
    width:16px;height:16px;background:#8cc2ff;border:2px solid #fff;border-radius:50%;
    box-shadow:0 2px 8px rgba(0,0,0,.35);cursor:pointer;transition:transform .15s ease, background .15s ease
  }
  .pin-dot:hover{transform:scale(1.15);background:#fff}
  .pin-dot.expanded{background:#fff;transform:scale(1.1)}
  .mini-label{
    font-size:10px;line-height:1;color:#e7eaee;text-shadow:0 1px 3px rgba(0,0,0,.85);
    white-space:nowrap;pointer-events:none;user-select:none;background:rgba(0,0,0,.45);padding:1px 4px;border-radius:4px
  }
  .pin-preview{
    display:none;position:absolute;bottom:calc(100% + 12px);left:50%;transform:translateX(-50%);
    background:#141a22f0;border:1px solid #1b2028;border-radius:10px;padding:6px 6px 8px 6px;backdrop-filter:blur(4px);
    min-width:110px;max-width:180px;cursor:pointer;pointer-events:auto;z-index:100
  }
  .pin-preview.visible{display:block}
  .pin-preview img,.pin-preview video{width:160px;height:120px;object-fit:cover;border-radius:8px;display:block}
  .pin-preview span{display:block;font-size:11px;text-align:center;margin-top:6px;color:#e7eaee}

  video{position:fixed;inset:0;object-fit:cover;width:100%;height:100%}
  canvas{display:none}
  button#torch{position:fixed;right:10px;bottom:10px;z-index:1001}

  /* Calibration UI OUTSIDE #hud so it’s interactive */
  #calibToggle{
    position:fixed;left:10px;top:10px;z-index:1001;background:#141a22;color:#e7eaee;
    border:1px solid #1b2028;border-radius:8px;padding:6px 10px;font-size:12px;cursor:pointer
  }
  #calibration{
    position:fixed;left:10px;top:50px;z-index:1001;background:#1118;color:#e7eaee;
    border:1px solid #1b2028;border-radius:10px;padding:10px;font-size:11px;display:none;pointer-events:auto
  }
  #calibration input{width:70px;margin:0 6px}
  #calibHUD{
    position:fixed;right:10px;top:10px;z-index:1001;background:#1118;border:1px solid #1b2028;
    border-radius:10px;padding:6px 8px;font-size:11px;pointer-events:none
  }
</style>
</head>
<body>
<video id="cam" playsinline autoplay muted></video>
<canvas id="work"></canvas>

<!-- HUD (non-interactive overlay) -->
<div id="hud">
  <div id="pins"></div>
  <div id="msg">Allow camera. Aim so 3–4 tags are visible.</div>
  <div id="stats">init…</div>
</div>

<!-- Interactive controls OUTSIDE #hud -->
<button id="calibToggle" aria-label="Calibration">Calib</button>
<div id="calibration">
  <div style="margin-bottom:6px">Calibration (mm)</div>
  <label>X:<input type="number" id="offsetX" value="0" step="1"></label>
  <label>Y:<input type="number" id="offsetY" value="0" step="1"></label>
  <div style="margin-top:8px">
    <button id="applyOffset" style="padding:2px 8px">Apply</button>
    <button id="resetOffset" style="padding:2px 8px;margin-left:6px">Reset</button>
    <button id="hideCalib" style="padding:2px 8px;margin-left:6px">Hide</button>
  </div>
</div>
<div id="calibHUD"></div>

<button id="torch" hidden>Torch</button>

<script src="https://unpkg.com/comlink/dist/umd/comlink.js"></script>
<script type="module">
/* ------------ errors ------------ */
addEventListener('error', e => { const m=`JS error: ${e.message}`; const n=document.getElementById('msg'); if(n) n.textContent=m; console.error(e); });
addEventListener('unhandledrejection', e => { const m=`Promise error: ${e.reason?.message ?? e.reason}`; const n=document.getElementById('msg'); if(n) n.textContent=m; console.error(e); });

/* ------------ config / paths ------------ */
const params = new URLSearchParams(location.search);
const id = params.get('id') || 'valdez-001';
const CFG_URL = `/data/${id}.json?v=21`;  // cache-bust
const APRILTAG_WORKER_URL = '/vendor/apriltag/apriltag.js';
const APRILTAG_WASM_JS    = '/vendor/apriltag/apriltag_wasm.js';
const APRILTAG_WASM_BIN   = '/vendor/apriltag/apriltag_wasm.wasm';

/* ------------ DOM ------------ */
const $ = s => document.querySelector(s);
const statsEl = $('#stats'), msgEl = $('#msg'), pinsEl = $('#pins');
const cam = $('#cam'), work = $('#work');
const wctx = work.getContext('2d', { willReadFrequently: true });

/* ------------ state ------------ */
let cfg, detector, stream, track;
const tagWorld=[], tagImage=[];
let H=null, lastGoodH=null, lastErr=Infinity;
let mode='init';
const pinEls=new Map(), pinSmoothed=new Map();
let SMOOTH_ALPHA = 0.05;
const imagePreloads = [];

/* calibration values (mm), persisted */
let calibrationOffset = {
  x: parseFloat(localStorage.getItem('calibOffsetX') || '0'),
  y: parseFloat(localStorage.getItem('calibOffsetY') || '0')
};

/* ------------ helpers ------------ */
async function loadJSON(url){
  const r = await fetch(url,{cache:'no-store'});
  if(!r.ok) throw new Error(`Config HTTP ${r.status}`);
  const txt = await r.text();
  return JSON.parse(txt.replace(/^\uFEFF/,'').replace(/^\s*\/\/.*$/mg,''));
}
function toGray(rgba,w,h){
  const g = new Uint8Array(w*h);
  for(let i=0,j=0;j<g.length;i+=4,j++) g[j]=(0.299*rgba[i]+0.587*rgba[i+1]+0.114*rgba[i+2])|0;
  return g;
}
async function loadAprilTag(){
  await Promise.all([APRILTAG_WASM_JS, APRILTAG_WASM_BIN].map(p =>
    fetch(p,{cache:'no-store'}).then(r => { if(!r.ok) throw new Error(`Missing: ${p}`); })
  ));
  const worker = new Worker(APRILTAG_WORKER_URL, { type: 'classic' });
  const RemoteApriltag = Comlink.wrap(worker);
  let readyResolve; const ready = new Promise(r => (readyResolve = r));
  const detector = await new RemoteApriltag(Comlink.proxy(() => readyResolve()));
  await ready;
  await detector.set_return_pose(0);
  await detector.set_max_detections(0);
  return detector;
}

/* ------------ math utils (robust homography) ------------ */
function mul3x3(A,B){ // row-major 3x3 Float64Array(9)
  const C=new Float64Array(9);
  for(let r=0;r<3;r++) for(let c=0;c<3;c++){
    C[r*3+c]=A[r*3+0]*B[0*3+c]+A[r*3+1]*B[1*3+c]+A[r*3+2]*B[2*3+c];
  }
  return C;
}
function det3x3(M){
  const a=M[0], b=M[1], c=M[2], d=M[3], e=M[4], f=M[5], g=M[6], h=M[7], i=M[8];
  return a*(e*i-f*h) - b*(d*i-f*g) + c*(d*h-e*g);
}
function inv3x3(M){
  const a=M[0], b=M[1], c=M[2], d=M[3], e=M[4], f=M[5], g=M[6], h=M[7], i=M[8];
  const A =  (e*i - f*h), B = -(b*i - c*h), C =  (b*f - c*e);
  const D = -(d*i - f*g), E =  (a*i - c*g), F = -(a*f - c*d);
  const G =  (d*h - e*g), H = -(a*h - b*g), I =  (a*e - b*d);
  const det = a*A + b*D + c*G; // same as det3x3
  const invDet = 1/(det || 1e-12);
  return new Float64Array([A*invDet, B*invDet, C*invDet, D*invDet, E*invDet, F*invDet, G*invDet, H*invDet, I*invDet]);
}
function applyH(H,X,Y){
  const u=H[0]*X+H[1]*Y+H[2], v=H[3]*X+H[4]*Y+H[5], w=H[6]*X+H[7]*Y+H[8];
  return [u/w, v/w];
}
function smooth(prev,next,alpha){ return !prev ? next : [prev[0]*(1-alpha)+next[0]*alpha, prev[1]*(1-alpha)+next[1]*alpha]; }

function normalize2D(pts){
  const n=pts.length; if(!n) return {T:new Float64Array([1,0,0, 0,1,0, 0,0,1]), pts:[]};
  let mx=0,my=0; for(const [x,y] of pts){ mx+=x; my+=y; } mx/=n; my/=n;
  let meanDist=0; for(const [x,y] of pts){ meanDist += Math.hypot(x-mx,y-my); }
  meanDist/=n; const s = Math.SQRT2 / (meanDist || 1);
  const T = new Float64Array([s,0,-s*mx, 0,s,-s*my, 0,0,1]);
  const np = pts.map(([x,y]) => [s*x - s*mx, s*y - s*my]);
  return {T, pts:np};
}

function dltHomography(world,image){
  const A=[], b=[];
  for (let i=0;i<world.length;i++){
    const [X,Y]=world[i], [u,v]=image[i];
    A.push([X,Y,1, 0,0,0, -u*X,-u*Y]); b.push(u);
    A.push([0,0,0, X,Y,1, -v*X,-v*Y]); b.push(v);
  }
  const n=8, m=A.length;
  const AtA=Array.from({length:n},()=>new Float64Array(n));
  const Atb=new Float64Array(n);
  for (let r=0;r<m;r++){
    const R=A[r], br=b[r];
    for (let i=0;i<n;i++){
      Atb[i]+=R[i]*br;
      for (let j=0;j<n;j++) AtA[i][j]+=R[i]*R[j];
    }
  }
  // Cholesky
  const L=Array.from({length:n},()=>new Float64Array(n));
  for (let i=0;i<n;i++){
    for (let j=0;j<=i;j++){
      let s=AtA[i][j];
      for (let k=0;k<j;k++) s-=L[i][k]*L[j][k];
      L[i][j]=(i===j)?Math.sqrt(Math.max(s,1e-12)):s/L[j][j];
    }
  }
  const y=new Float64Array(n);
  for (let i=0;i<n;i++){
    let s=Atb[i]; for (let k=0;k<i;k++) s-=L[i][k]*y[k]; y[i]=s/L[i][i];
  }
  const x=new Float64Array(n);
  for (let i=n-1;i>=0;i--){
    let s=y[i]; for (let k=i+1;k<n;k++) s-=L[k][i]*x[k]; x[i]=s/L[i][i];
  }
  return new Float64Array([x[0],x[1],x[2], x[3],x[4],x[5], x[6],x[7], 1]);
}
function denormHomography(Hn, Tsrc, Tdst){ // H = Tdst^-1 * Hn * Tsrc
  const TdInv = inv3x3(Tdst);
  return mul3x3(mul3x3(TdInv, Hn), Tsrc);
}
function proj(H, [X,Y]){ return applyH(H,X,Y); }
function rmse(H, world, image){
  let s=0; for(let k=0;k<world.length;k++){
    const [pu,pv]=proj(H, world[k]); const [u,v]=image[k];
    const du=pu-u, dv=pv-v; s += du*du + dv*dv;
  }
  return Math.sqrt(s / Math.max(1, world.length));
}

function robustHomography(world, image){
  if (world.length < 4) return {H:null, rmse:Infinity};

  // Normalize both sets
  const nW = normalize2D(world);
  const nI = normalize2D(image);

  // Build up to first 100 4-point subsets
  const idx = [...world.keys()];
  const subsets = [];
  for (let a=0;a<idx.length-3;a++)
    for (let b=a+1;b<idx.length-2;b++)
      for (let c=b+1;c<idx.length-1;c++)
        for (let d=c+1;d<idx.length;d++)
          subsets.push([a,b,c,d]);
  // shuffle & cap
  for (let i=subsets.length-1;i>0;i--){
    const j=(Math.random()*(i+1))|0; [subsets[i],subsets[j]]=[subsets[j],subsets[i]];
  }
  subsets.length = Math.min(subsets.length, 100);

  let bestH=null, bestErr=Infinity;

  for (const s of subsets){
    const W4 = s.map(i => nW.pts[i]), I4 = s.map(i => nI.pts[i]);
    const Hn = dltHomography(W4, I4);
    const Hc = denormHomography(Hn, nW.T, nI.T);

    // inlier selection (~8 px threshold)
    const inliers=[];
    for (let k=0;k<world.length;k++){
      const [pu,pv]=proj(Hc, world[k]);
      const [u,v]=image[k];
      if (Math.hypot(pu-u,pv-v) < 8) inliers.push(k);
    }
    if (inliers.length < 4) continue;

    // refine on inliers
    const Wr = inliers.map(i => world[i]);
    const Ir = inliers.map(i => image[i]);
    const nWr = normalize2D(Wr), nIr = normalize2D(Ir);
    const Hr = dltHomography(nWr.pts, nIr.pts);
    const Hc2 = denormHomography(Hr, nWr.T, nIr.T);
    const e = rmse(Hc2, Wr, Ir);
    if (e < bestErr){ bestErr=e; bestH=Hc2; }
  }

  // fallback: normalized DLT over all
  if (!bestH){
    const nW0 = normalize2D(world), nI0 = normalize2D(image);
    const Hn = dltHomography(nW0.pts, nI0.pts);
    bestH = denormHomography(Hn, nW0.T, nI0.T);
    bestErr = rmse(bestH, world, image);
  }

  return {H:bestH, rmse:bestErr};
}

/* detection normalization */
function normalizeDetections(d){
  if (!d) return [];
  if (typeof d === 'string') { try { d = JSON.parse(d); } catch {} }
  if (Array.isArray(d)) return d;
  for (const k of ['result','results','detections','tags']) {
    if (Array.isArray(d[k])) return d[k];
  }
  if (typeof d === 'object') return Object.values(d);
  return [];
}
const getId = det => det.id ?? det.tag_id ?? det.tagId ?? det.code ?? det.i;
function getCorners(det){
  let c = null;
  if (det.corners) c = det.corners;
  else if (det.c) c = det.c;
  else if (det.p) c = det.p;
  else if (det.lb && det.lt && det.rt && det.rb) c = [det.lt, det.rt, det.rb, det.lb];
  else if (det.tl && det.tr && det.br && det.bl) c = [det.tl, det.tr, det.br, det.bl];
  else if (det.points) c = det.points;
  else if (det.corner || det.corner_pts) c = det.corner || det.corner_pts;
  if (!c && typeof det === 'object' && det['0'] && det['3']) c = [det['0'], det['1'], det['2'], det['3']];
  if (Array.isArray(c) && c.length === 8 && typeof c[0] === 'number') {
    c = [[c[0],c[1]],[c[2],c[3]],[c[4],c[5]],[c[6],c[7]]];
  }
  if (!Array.isArray(c) && typeof c === 'object') c = Object.values(c);
  if (Array.isArray(c) && c.length >= 4) {
    const pts = c.slice(0,4).map(p => {
      if (Array.isArray(p)) return [Number(p[0]), Number(p[1])];
      if (p && typeof p === 'object') return [Number(p.x ?? p.u ?? p[0]), Number(p.y ?? p.v ?? p[1])];
      return [NaN, NaN];
    });
    if (pts.every(q => Number.isFinite(q[0]) && Number.isFinite(q[1]))) return pts;
  }
  return null;
}
const centerOf = corners => {
  const [a,b,c,d] = corners; return [(a[0]+b[0]+c[0]+d[0])/4, (a[1]+b[1]+c[1]+d[1])/4];
}

/* pairing — centers primary; if <4 centers, use ALL corners from visible tags */
function gatherCenterPairs(dets, sx, sy){
  tagWorld.length=0; tagImage.length=0;
  const lut=new Map(cfg.apriltags.map(t=>[t.id,t]));
  for(const d of normalizeDetections(dets)){
    const id=getId(d); const t=lut.get(id); if(!t) continue;
    const corners=getCorners(d); if(!corners) continue;
    const [u,v]=centerOf(corners);
    tagWorld.push([t.center_xy_mm[0], t.center_xy_mm[1]]);
    tagImage.push([u/sx, v/sy]);
  }
  return tagWorld.length;
}
function gatherCornersFromAllVisibleTags(dets, sx, sy){
  tagWorld.length=0; tagImage.length=0;
  const lut=new Map(cfg.apriltags.map(t=>[t.id,t]));
  for(const d of normalizeDetections(dets)){
    const id=getId(d); const t=lut.get(id); if(!t) continue;
    const corners=getCorners(d); if(!corners) continue;
    const s=t.size_mm/2, wx=t.center_xy_mm[0], wy=t.center_xy_mm[1];
    const world=[[wx-s,wy+s],[wx+s,wy+s],[wx+s,wy-s],[wx-s,wy-s]];
    const image=corners.map(([u,v])=>[u/sx, v/sy]);
    for(let i=0;i<4;i++){ tagWorld.push(world[i]); tagImage.push(image[i]); }
  }
  return tagWorld.length;
}

/* ------------ init ------------ */
function updateStats(n){ statsEl.textContent = `${n} tag${n===1?'':'s'} | ${mode}${lastGoodH?` | rmse ${lastErr.toFixed(1)}px`:''}`; }

async function init(){
  cfg = await loadJSON(CFG_URL);

  if (cfg.calibration && Number.isFinite(cfg.calibration.smooth_alpha)) {
    SMOOTH_ALPHA = cfg.calibration.smooth_alpha;
  }

  if (!cfg.hotspots || !cfg.hotspots.length) {
    cfg.hotspots = [{ xy_mm: [cfg.map_size_mm[0]/2, -cfg.map_size_mm[1]/2], z_mm: 0, label: 'Map center' }];
  }

  // preload images
  for (const h of cfg.hotspots){
    if (h.img && !/\.(mp4|mov|webm|m4v)$/i.test(h.img)) {
      const pre = new Image(); pre.src = h.img; imagePreloads.push(pre);
    }
  }

  detector = await loadAprilTag();

  // camera
  stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: {ideal:'environment'} } });
  cam.srcObject = stream; await cam.play();
  track = stream.getVideoTracks?.()[0];

  // torch (best-effort)
  try {
    const caps = track?.getCapabilities?.();
    if (caps?.torch) {
      const btn = document.getElementById('torch');
      btn.hidden = false;
      btn.onclick = async () => {
        const st = track.getSettings?.() || {};
        await track.applyConstraints({ advanced: [{ torch: !st.torch }]});
      };
    }
  } catch {}

  // working canvas scale (~1280 wide)
  const vw=cam.videoWidth, vh=cam.videoHeight, target=Math.min(1280, vw), sc=target/vw;
  work.width=Math.round(vw*sc); work.height=Math.round(vh*sc);

  // build pins: dot + label + preview
  for (const h of cfg.hotspots){
    const el = document.createElement('div'); el.className = 'pin';
    const stack = document.createElement('div'); stack.className = 'stack';
    const dot = document.createElement('div'); dot.className = 'pin-dot';
    const mini = document.createElement('span'); mini.className = 'mini-label'; mini.textContent = h.label || '';
    stack.appendChild(dot); stack.appendChild(mini);

    const preview = document.createElement('div'); preview.className = 'pin-preview';
    if (h.img) {
      const isVideo = /\.(mp4|mov|webm|m4v)$/i.test(h.img);
      if (isVideo) {
        const video = document.createElement('video');
        Object.assign(video, { src:h.img, autoplay:true, loop:true, muted:true, playsInline:true });
        video.onerror = () => { console.warn('Video failed:', h.img); video.style.display='none'; };
        preview.appendChild(video);
        preview.onclick = (e) => {
          e.stopPropagation();
          if (video.requestFullscreen) video.requestFullscreen();
          else if (video.webkitRequestFullscreen) video.webkitRequestFullscreen();
        };
      } else {
        const img = document.createElement('img'); img.src = h.img;
        img.onerror = () => { console.warn('Image failed:', h.img); img.style.display='none'; };
        preview.appendChild(img);
        preview.onclick = (e) => { e.stopPropagation(); showFullscreenImage(h.img, h.label); };
      }
    }
    const cap = document.createElement('span'); cap.textContent = h.label || '';
    preview.appendChild(cap);

    // toggle preview
    stack.onclick = (e) => {
      e.stopPropagation();
      if (window.currentExpanded && window.currentExpanded !== preview) {
        window.currentExpanded.classList.remove('visible');
        window.currentExpanded.previousSibling.querySelector('.pin-dot')?.classList.remove('expanded');
      }
      const isOpen = preview.classList.contains('visible');
      if (isOpen) {
        preview.classList.remove('visible'); dot.classList.remove('expanded'); window.currentExpanded = null;
      } else {
        preview.classList.add('visible'); dot.classList.add('expanded'); window.currentExpanded = preview;
      }
    };

    el.appendChild(stack); el.appendChild(preview); pinsEl.appendChild(el);
    pinEls.set(h, el);
  }

  document.addEventListener('click', () => {
    if (window.currentExpanded) {
      window.currentExpanded.classList.remove('visible');
      window.currentExpanded.previousSibling.querySelector('.pin-dot')?.classList.remove('expanded');
      window.currentExpanded = null;
    }
  });

  setupCalibrationControls();  // interactive, outside HUD
  requestAnimationFrame(loop);
}

/* fullscreen image */
function showFullscreenImage(src, label) {
  const overlay = document.createElement('div');
  overlay.style.cssText = 'position:fixed;inset:0;z-index:1000;background:rgba(0,0,0,.9);display:flex;align-items:center;justify-content:center;flex-direction:column;cursor:pointer';
  const img = document.createElement('img');
  img.src = src; img.style.cssText = 'max-width:95vw;max-height:85vh;object-fit:contain;border-radius:12px';
  const caption = document.createElement('div');
  caption.textContent = label || ''; caption.style.cssText = 'color:#fff;font-size:18px;margin-top:16px;text-align:center;padding:0 20px';
  overlay.onclick = () => document.body.removeChild(overlay);
  document.addEventListener('keydown', function esc(e){ if(e.key==='Escape'){ document.body.removeChild(overlay); document.removeEventListener('keydown',esc);} });
  overlay.appendChild(img); overlay.appendChild(caption); document.body.appendChild(overlay);
}

/* layout: JSON calibration (mm) + panel offsets (mm) */
function layoutPins(){
  if(!H) return;
  const vw=cam.videoWidth, vh=cam.videoHeight;

  const cal = (cfg && cfg.calibration) ? cfg.calibration : null;
  const sxmm = cal?.scale_mm?.[0] ?? 1;
  const symm = cal?.scale_mm?.[1] ?? 1;
  const oxmm = cal?.offset_mm?.[0] ?? 0;
  const oymm = cal?.offset_mm?.[1] ?? 0;

  const uxmm = calibrationOffset.x || 0;
  const uymm = calibrationOffset.y || 0;

  for(const h of cfg.hotspots){
    const el = pinEls.get(h); if(!el) continue;

    // world-space adjustments in mm
    const Xw = h.xy_mm[0] * sxmm + oxmm + uxmm;
    const Yw = h.xy_mm[1] * symm + oymm + uymm;

    // project
    let [u,v]=applyH(H, Xw, Yw);

    const sm=smooth(pinSmoothed.get(h),[u,v],SMOOTH_ALPHA);
    pinSmoothed.set(h,sm);
    el.style.left=`${(sm[0]/vw)*100}vw`;
    el.style.top =`${(sm[1]/vh)*100}vh`;
  }
}

/* main loop with robust solve + gating */
async function loop(){
  try{
    wctx.drawImage(cam,0,0,work.width,work.height);
    const frame=wctx.getImageData(0,0,work.width,work.height);
    const gray=toGray(frame.data, work.width, work.height);
    const dets=await detector.detect(gray, work.width, work.height);

    const sx=cam.videoWidth/work.width, sy=cam.videoHeight/work.height;

    // Build correspondences
    const seenCenters = gatherCenterPairs(dets, sx, sy);
    mode = 'centers';
    if (seenCenters < 4) {
      const seenCorners = gatherCornersFromAllVisibleTags(dets, sx, sy);
      mode = (seenCorners >= 4) ? 'corners' : 'insufficient';
    }

    if (mode !== 'insufficient'){
      const {H:Hp, rmse:err} = robustHomography(tagWorld, tagImage);
      const GOOD = Hp && Number.isFinite(Hp[0]) && Number.isFinite(Hp[8]) && err < 6.0; // ~6px gate
      if (GOOD){
        lastGoodH = Hp; lastErr = err;
      }
      H = lastGoodH || null;
    } else {
      H = lastGoodH || null;
    }

    if (H){
      msgEl.textContent = '';
      layoutPins();
      updateStats(normalizeDetections(dets).length);
    } else {
      msgEl.textContent = 'Move closer until 3–4 tags are visible';
      updateStats(normalizeDetections(dets).length);
    }
  } catch(e){
    const m=(e && (e.stack||e.message)) || String(e);
    msgEl.textContent=m;
    console.error(e);
  }
  requestAnimationFrame(loop);
}

/* calibration UI (persisted) */
function setupCalibrationControls() {
  const toggleBtn = document.getElementById('calibToggle');
  const panel     = document.getElementById('calibration');
  const offsetX   = document.getElementById('offsetX');
  const offsetY   = document.getElementById('offsetY');
  const applyBtn  = document.getElementById('applyOffset');
  const resetBtn  = document.getElementById('resetOffset');
  const hideBtn   = document.getElementById('hideCalib');
  const hud       = document.getElementById('calibHUD');

  offsetX.value = calibrationOffset.x;
  offsetY.value = calibrationOffset.y;

  toggleBtn.onclick = () => {
    panel.style.display = (panel.style.display === 'none' || !panel.style.display) ? 'block' : 'none';
  };
  if (params.get('calib') === '1') panel.style.display = 'block';

  document.addEventListener('keydown', (e) => {
    if (e.key === 'c' || e.key === 'C') {
      panel.style.display = (panel.style.display === 'none' || !panel.style.display) ? 'block' : 'none';
    }
  });

  const updateHUD = () => {
    hud.textContent = `calib (mm): X=${(calibrationOffset.x||0).toFixed(1)}, Y=${(calibrationOffset.y||0).toFixed(1)} | smooth=${SMOOTH_ALPHA}`;
  };
  updateHUD();

  applyBtn.onclick = () => {
    const x = parseFloat(offsetX.value);
    const y = parseFloat(offsetY.value);
    calibrationOffset.x = Number.isFinite(x) ? x : 0;
    calibrationOffset.y = Number.isFinite(y) ? y : 0;
    localStorage.setItem('calibOffsetX', calibrationOffset.x);
    localStorage.setItem('calibOffsetY', calibrationOffset.y);
    updateHUD();
  };

  resetBtn.onclick = () => {
    calibrationOffset.x = 0;
    calibrationOffset.y = 0;
    offsetX.value = 0; offsetY.value = 0;
    localStorage.removeItem('calibOffsetX');
    localStorage.removeItem('calibOffsetY');
    updateHUD();
  };

  hideBtn.onclick = () => { panel.style.display = 'none'; };
}

/* start */
init().catch(e => { const m=(e && (e.stack||e.message))||String(e); msgEl.textContent=m; console.error(e); });
</script>
</body>
</html>
