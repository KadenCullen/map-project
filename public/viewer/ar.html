<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Wood Map AR</title>
<style>
  :root { color-scheme: dark; }
  html,body{margin:0;height:100%;background:#0b0d10;color:#e7eaee;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  #hud{position:fixed;inset:0;pointer-events:none}
  #stats{position:fixed;left:10px;bottom:10px;background:#1118;padding:8px 10px;border:1px solid #1b2028;border-radius:10px;font-size:12px}
  #msg{position:fixed;top:10px;left:50%;transform:translateX(-50%);background:#1118;padding:8px 10px;border:1px solid #1b2028;border-radius:10px;font-size:12px;max-width:92vw;white-space:pre-wrap}
  #pins{position:absolute;inset:0;pointer-events:none}
  
  /* Pin styles - now starts as a small dot */
  .pin{position:absolute;transform:translate(-50%,-50%);pointer-events:auto}
  
  /* The dot marker */
  .pin-dot{
    width:16px;height:16px;
    background:#8cc2ff;
    border:2px solid #fff;
    border-radius:50%;
    cursor:pointer;
    transition:all 0.2s ease;
    box-shadow:0 2px 8px rgba(0,0,0,0.3);
  }
  .pin-dot:hover{
    transform:scale(1.2);
    background:#fff;
  }
  .pin-dot.expanded{
    background:#fff;
    transform:scale(1.1);
  }
  
  /* Preview container */
  .pin-preview{
    display:none;
    position:absolute;
    bottom:calc(100% + 10px);
    left:50%;
    transform:translateX(-50%);
    background:#141a22ee;
    border:1px solid #1b2028;
    border-radius:10px;
    padding:6px;
    backdrop-filter:blur(4px);
    min-width:110px;
    cursor:pointer;
  }
  .pin-preview.visible{
    display:block;
  }
  .pin-preview img, .pin-preview video{
    width:100px;
    height:75px;
    object-fit:cover;
    border-radius:6px;
    display:block;
  }
  .pin-preview span{
    display:block;
    font-size:11px;
    text-align:center;
    margin-top:4px;
    color:#e7eaee;
  }
  
  video{position:fixed;inset:0;object-fit:cover;width:100%;height:100%}
  canvas{display:none}
  button#torch{position:fixed;right:10px;bottom:10px;z-index:10}
</style>
</head>
<body>
<video id="cam" playsinline autoplay muted></video>
<canvas id="work"></canvas>
<div id="hud">
  <div id="pins"></div>
  <div id="msg">Allow camera. Aim so 3–4 tags are visible.</div>
  <div id="stats">init…</div>
</div>
<button id="torch" hidden>Torch</button>

<!-- Comlink for worker RPC -->
<script src="https://unpkg.com/comlink/dist/umd/comlink.js"></script>

<script type="module">
addEventListener('error', e => { const m=`JS error: ${e.message}`; const n=document.getElementById('msg'); if(n) n.textContent=m; console.error(e); });
addEventListener('unhandledrejection', e => { const m=`Promise error: ${e.reason?.message ?? e.reason}`; const n=document.getElementById('msg'); if(n) n.textContent=m; console.error(e); });

/* ----------- config / paths ----------- */
const params = new URLSearchParams(location.search);
const id = params.get('id') || 'valdez-001';
const CFG_URL = `/data/${id}.json?v=13`;  // cache-bust
const APRILTAG_WORKER_URL = '/vendor/apriltag/apriltag.js';
const APRILTAG_WASM_JS    = '/vendor/apriltag/apriltag_wasm.js';
const APRILTAG_WASM_BIN   = '/vendor/apriltag/apriltag_wasm.wasm';

/* ----------- DOM ----------- */
const $ = s => document.querySelector(s);
const statsEl = $('#stats'), msgEl = $('#msg'), pinsEl = $('#pins');
const cam = $('#cam'), work = $('#work');
const wctx = work.getContext('2d', { willReadFrequently: true });

/* ----------- helpers ----------- */
async function loadJSON(url){
  const r = await fetch(url,{cache:'no-store'});
  if(!r.ok) throw new Error(`Config HTTP ${r.status}`);
  const txt = await r.text();
  return JSON.parse(txt.replace(/^\uFEFF/,'').replace(/^\s*\/\/.*$/mg,''));
}
function toGray(rgba,w,h){
  const g = new Uint8Array(w*h);
  for(let i=0,j=0;j<g.length;i+=4,j++) g[j]=(0.299*rgba[i]+0.587*rgba[i+1]+0.114*rgba[i+2])|0;
  return g;
}
async function loadAprilTag(){
  await Promise.all([APRILTAG_WASM_JS, APRILTAG_WASM_BIN].map(p =>
    fetch(p,{cache:'no-store'}).then(r => { if(!r.ok) throw new Error(`Missing: ${p}`); })
  ));
  const worker = new Worker(APRILTAG_WORKER_URL, { type: 'classic' });
  const RemoteApriltag = Comlink.wrap(worker);
  let readyResolve; const ready = new Promise(r => (readyResolve = r));
  const detector = await new RemoteApriltag(Comlink.proxy(() => readyResolve()));
  await ready;
  await detector.set_return_pose(0);
  await detector.set_max_detections(0);
  return detector;
}

/* ----------- fullscreen image viewer ----------- */
function showFullscreenImage(src, label) {
  const overlay = document.createElement('div');
  overlay.style.cssText = `
    position: fixed; inset: 0; z-index: 1000; 
    background: rgba(0,0,0,0.9); display: flex; 
    align-items: center; justify-content: center; 
    flex-direction: column; cursor: pointer;
  `;
  
  const img = document.createElement('img');
  img.src = src;
  img.style.cssText = `
    max-width: 95vw; max-height: 85vh; 
    object-fit: contain; border-radius: 12px;
  `;
  
  const caption = document.createElement('div');
  caption.textContent = label;
  caption.style.cssText = `
    color: white; font-size: 18px; margin-top: 16px; 
    text-align: center; padding: 0 20px;
  `;
  
  overlay.onclick = () => document.body.removeChild(overlay);
  document.addEventListener('keydown', function closeOnEscape(e) {
    if (e.key === 'Escape') {
      document.body.removeChild(overlay);
      document.removeEventListener('keydown', closeOnEscape);
    }
  });
  
  overlay.appendChild(img);
  overlay.appendChild(caption);
  document.body.appendChild(overlay);
}

/* ----------- homography ----------- */
function computeHomography(world,image){
  const A=[], b=[];
  for(let i=0;i<world.length;i++){
    const [X,Y]=world[i],[u,v]=image[i];
    A.push([X,Y,1, 0,0,0, -u*X,-u*Y]); b.push(u);
    A.push([0,0,0, X,Y,1, -v*X,-v*Y]); b.push(v);
  }
  const n=8, m=A.length, AtA=Array.from({length:n},()=>new Float64Array(n)), Atb=new Float64Array(n);
  for(let r=0;r<m;r++){ const R=A[r], br=b[r]; for(let i=0;i<n;i++){ Atb[i]+=R[i]*br; for(let j=0;j<n;j++) AtA[i][j]+=R[i]*R[j]; } }
  function chol(A,b){ const n=A.length,L=Array.from({length:n},()=>new Float64Array(n));
    for(let i=0;i<n;i++){ for(let j=0;j<=i;j++){ let s=A[i][j]; for(let k=0;k<j;k++) s-=L[i][k]*L[j][k]; L[i][j]=(i===j)?Math.sqrt(Math.max(s,1e-12)):s/L[j][j]; } }
    const y=new Float64Array(n); for(let i=0;i<n;i++){ let s=b[i]; for(let k=0;k<i;k++) s-=L[i][k]*y[k]; y[i]=s/L[i][i]; }
    const x=new Float64Array(n); for(let i=n-1;i>=0;i--){ let s=y[i]; for(let k=i+1;k<n;k++) s-=L[k][i]*x[k]; x[i]=s/L[i][i]; } return x; }
  const h=chol(AtA,Atb);
  return new Float64Array([h[0],h[1],h[2], h[3],h[4],h[5], h[6],h[7], 1]);
}
const applyH=(H,X,Y)=>{const u=H[0]*X+H[1]*Y+H[2], v=H[3]*X+H[4]*Y+H[5], w=H[6]*X+H[7]*Y+H[8]; return [u/w,v/w];};
const smooth=(p,n,a=0.25)=>!p?n:[p[0]*(1-a)+n[0]*a, p[1]*(1-a)+n[1]*a];

/* ----------- detection normalization ----------- */
function normalizeDetections(d){
  if (!d) return [];
  if (typeof d === 'string') { try { d = JSON.parse(d); } catch {} }
  if (Array.isArray(d)) return d;
  for (const k of ['result','results','detections','tags']) {
    if (Array.isArray(d[k])) return d[k];
  }
  if (typeof d === 'object') return Object.values(d);
  return [];
}
const getId = det => det.id ?? det.tag_id ?? det.tagId ?? det.code ?? det.i;
function getCorners(det){
  let c = null;
  if (det.corners) c = det.corners;
  else if (det.c) c = det.c;
  else if (det.p) c = det.p;
  else if (det.lb && det.lt && det.rt && det.rb) c = [det.lt, det.rt, det.rb, det.lb];
  else if (det.tl && det.tr && det.br && det.bl) c = [det.tl, det.tr, det.br, det.bl];
  else if (det.points) c = det.points;
  else if (det.corner || det.corner_pts) c = det.corner || det.corner_pts;
  if (!c && typeof det === 'object' && det['0'] && det['3']) c = [det['0'], det['1'], det['2'], det['3']];
  if (Array.isArray(c) && c.length === 8 && typeof c[0] === 'number') {
    c = [[c[0],c[1]],[c[2],c[3]],[c[4],c[5]],[c[6],c[7]]];
  }
  if (!Array.isArray(c) && typeof c === 'object') c = Object.values(c);
  if (Array.isArray(c) && c.length >= 4) {
    const pts = c.slice(0,4).map(p => {
      if (Array.isArray(p)) return [Number(p[0]), Number(p[1])];
      if (p && typeof p === 'object') return [Number(p.x ?? p.u ?? p[0]), Number(p.y ?? p.v ?? p[1])];
      return [NaN, NaN];
    });
    if (pts.every(q => Number.isFinite(q[0]) && Number.isFinite(q[1]))) return pts;
  }
  return null;
}
const centerOf = corners => {
  const [a,b,c,d] = corners; return [(a[0]+b[0]+c[0]+d[0])/4, (a[1]+b[1]+c[1]+d[1])/4];
};

/* ----------- main ----------- */
let cfg, detector, stream, track;
const tagWorld=[], tagImage=[];
let H=null;
const pinEls=new Map(), pinSmoothed=new Map();
const K_MIN_CENTERS=4;
let currentExpanded = null; // Track which pin is expanded

function updateStats(n){ statsEl.textContent = `${n} tag${n===1?'':'s'}`; }
function logError(e){ const m=(e && (e.stack||e.message)) || String(e); msgEl.textContent=m; console.error(e); }

async function init(){
  cfg = await loadJSON(CFG_URL);

  // ensure at least one demo pin so you see something
  if (!cfg.hotspots || !cfg.hotspots.length) {
    cfg.hotspots = [{ xy_mm: [cfg.map_size_mm[0]/2, cfg.map_size_mm[1]/2], z_mm: 0, label: 'Map center' }];
  }

  detector = await loadAprilTag();

  // Camera
  stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: {ideal:'environment'} } });
  cam.srcObject = stream; await cam.play();
  track = stream.getVideoTracks?.()[0];

  // Torch (best effort)
  try {
    const caps = track?.getCapabilities?.();
    if (caps?.torch) {
      const btn = document.getElementById('torch');
      btn.hidden = false;
      btn.onclick = async () => {
        const st = track.getSettings?.() || {};
        await track.applyConstraints({ advanced: [{ torch: !st.torch }]});
      };
    }
  } catch {}

  // Plenty of pixels (cap ~1280 wide)
  const vw=cam.videoWidth, vh=cam.videoHeight, target=Math.min(1280, vw), sc=target/vw;
  work.width=Math.round(vw*sc); work.height=Math.round(vh*sc);

  // Create progressive disclosure pins (dots → preview → fullscreen)
  for (const h of cfg.hotspots){
    const el = document.createElement('div'); 
    el.className = 'pin';
    
    // The dot marker
    const dot = document.createElement('div');
    dot.className = 'pin-dot';
    
    // Preview container (hidden initially)
    const preview = document.createElement('div');
    preview.className = 'pin-preview';
    
    // Add media to preview if exists
    if (h.img) {
      const isVideo = h.img.match(/\.(mp4|mov|webm|m4v)$/i);
      
      if (isVideo) {
        const video = document.createElement('video');
        video.src = h.img;
        video.controls = false;
        video.autoplay = true;
        video.loop = true;
        video.muted = true;
        video.playsInline = true;
        
        video.onerror = () => {
          console.warn('Video failed to load:', h.img);
          video.style.display = 'none';
        };
        
        preview.appendChild(video);
        
        // Click preview for fullscreen video
        preview.onclick = (e) => {
          e.stopPropagation();
          if (video.requestFullscreen) {
            video.requestFullscreen();
          } else if (video.webkitRequestFullscreen) {
            video.webkitRequestFullscreen();
          }
        };
      } else {
        const img = document.createElement('img');
        img.src = h.img;
        
        img.onerror = () => {
          console.warn('Image failed to load:', h.img);
          img.style.display = 'none';
        };
        
        preview.appendChild(img);
        
        // Click preview for fullscreen image
        preview.onclick = (e) => {
          e.stopPropagation();
          showFullscreenImage(h.img, h.label);
        };
      }
    }
    
    // Add label to preview
    const label = document.createElement('span');
    label.textContent = h.label || '';
    preview.appendChild(label);
    
    // Dot click handler - toggle preview
    dot.onclick = (e) => {
      e.stopPropagation();
      
      // Close any other expanded pin
      if (currentExpanded && currentExpanded !== preview) {
        currentExpanded.classList.remove('visible');
        currentExpanded.previousSibling.classList.remove('expanded');
      }
      
      // Toggle this pin
      const isExpanded = preview.classList.contains('visible');
      if (isExpanded) {
        preview.classList.remove('visible');
        dot.classList.remove('expanded');
        currentExpanded = null;
      } else {
        preview.classList.add('visible');
        dot.classList.add('expanded');
        currentExpanded = preview;
      }
    };
    
    el.appendChild(dot);
    el.appendChild(preview);
    pinsEl.appendChild(el); 
    pinEls.set(h, el);
  }
  
  // Click anywhere else to close previews
  document.addEventListener('click', () => {
    if (currentExpanded) {
      currentExpanded.classList.remove('visible');
      currentExpanded.previousSibling.classList.remove('expanded');
      currentExpanded = null;
    }
  });

  msgEl.textContent='Aim so 3–4 tags are visible';
  requestAnimationFrame(loop);
}

function gatherCenters(list, sx, sy){
  // Build world/image pairs from tag centers (robust to corner ordering)
  tagWorld.length=0; tagImage.length=0;
  const lut=new Map(cfg.apriltags.map(t=>[t.id,t]));
  for(const d of normalizeDetections(list)){
    const id=getId(d); const t=lut.get(id); if(!t) continue;
    const corners=getCorners(d); if(!corners) continue;
    const [u,v]=centerOf(corners);
    tagWorld.push([t.center_xy_mm[0], t.center_xy_mm[1]]);
    tagImage.push([u/sx, v/sy]);
  }
}
function gatherOneTagCorners(list, sx, sy){
  // Fallback: use the first tag's corners (gives 4 points)
  tagWorld.length=0; tagImage.length=0;
  const lut=new Map(cfg.apriltags.map(t=>[t.id,t]));
  for(const d of normalizeDetections(list)){
    const id=getId(d); const t=lut.get(id); if(!t) continue;
    const corners=getCorners(d); if(!corners) continue;
    const s=t.size_mm/2, wx=t.center_xy_mm[0], wy=t.center_xy_mm[1];
    const world=[[wx-s,wy+s],[wx+s,wy+s],[wx+s,wy-s],[wx-s,wy-s]];
    const image=corners.map(([u,v])=>[u/sx, v/sy]);
    for(let i=0;i<4;i++){ tagWorld.push(world[i]); tagImage.push(image[i]); }
    break; // only first tag needed
  }
}

function layoutPins(){
  if(!H) return;
  const vw=cam.videoWidth, vh=cam.videoHeight;
  
  // Simply position pins at their true locations - no collision detection
  for(const h of cfg.hotspots){
    const el=pinEls.get(h); if(!el) continue;
    const [u,v]=applyH(H,h.xy_mm[0],h.xy_mm[1]);
    const sm=smooth(pinSmoothed.get(h),[u,v],0.05);
    pinSmoothed.set(h,sm);
    el.style.left=`${(sm[0]/vw)*100}vw`;
    el.style.top=`${(sm[1]/vh)*100}vh`;
  }
}

async function loop(){
  try{
    wctx.drawImage(cam,0,0,work.width,work.height);
    const frame=wctx.getImageData(0,0,work.width,work.height);
    const gray=toGray(frame.data, work.width, work.height);
    const dets=await detector.detect(gray, work.width, work.height);

    const sx=cam.videoWidth/work.width, sy=cam.videoHeight/work.height;
    // Prefer centers if we have ≥4 tags; else fall back to one tag's corners
    gatherCenters(dets, sx, sy);
    if (tagWorld.length >= K_MIN_CENTERS) {
      H = computeHomography(tagWorld, tagImage);
    } else {
      gatherOneTagCorners(dets, sx, sy);
      if (tagWorld.length === 4) H = computeHomography(tagWorld, tagImage);
    }

    if (H){
      msgEl.textContent = '';
      layoutPins();
      updateStats(normalizeDetections(dets).length);
    } else {
      msgEl.textContent = 'Move closer until 3–4 tags are visible';
      updateStats(normalizeDetections(dets).length);
    }
  } catch(e){ const m=(e && (e.stack||e.message))||String(e); msgEl.textContent=m; console.error(e); }
  requestAnimationFrame(loop);
}

init().catch(e => { const m=(e && (e.stack||e.message))||String(e); msgEl.textContent=m; console.error(e); });
</script>
</body>
</html>
