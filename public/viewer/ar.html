<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Wood Map AR</title>
<style>
  :root { color-scheme: dark; }
  html,body{margin:0;height:100%;background:#0b0d10;color:#e7eaee;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  #hud{position:fixed;inset:0;pointer-events:none}
  #stats{position:fixed;left:10px;bottom:10px;background:#1118;padding:8px 10px;border:1px solid #1b2028;border-radius:10px;font-size:12px}
  #msg{position:fixed;top:10px;left:50%;transform:translateX(-50%);background:#1118;padding:8px 10px;border:1px solid #1b2028;border-radius:10px;font-size:12px;max-width:92vw;white-space:pre-wrap}
  #pins{position:absolute;inset:0;pointer-events:none}
  .pin{position:absolute;transform:translate(-50%,-100%);padding:4px 6px;border-radius:10px;border:1px solid #1b2028;background:#141a22cc;backdrop-filter:blur(3px);pointer-events:auto}
  .pin span{font-size:12px}
  video{position:fixed;inset:0;object-fit:cover;width:100%;height:100%}
  canvas{display:none}
  button#torch{position:fixed;right:10px;bottom:10px;z-index:10}
</style>
</head>
<body>
<video id="cam" playsinline autoplay muted></video>
<canvas id="work"></canvas>
<div id="hud">
  <div id="pins"></div>
  <div id="msg">Allow camera. Aim so 3–4 tags are visible.</div>
  <div id="stats">init…</div>
</div>
<button id="torch" hidden>Torch</button>

<!-- Comlink for worker RPC -->
<script src="https://unpkg.com/comlink/dist/umd/comlink.js"></script>

<script type="module">
addEventListener('error', e => { const m=`JS error: ${e.message}`; const n=document.getElementById('msg'); if(n) n.textContent=m; console.error(e); });
addEventListener('unhandledrejection', e => { const m=`Promise error: ${e.reason?.message ?? e.reason}`; const n=document.getElementById('msg'); if(n) n.textContent=m; console.error(e); });

/* ----------- config / paths ----------- */
const params = new URLSearchParams(location.search);
const id = params.get('id') || 'valdez-001';
const CFG_URL = `/data/${id}.json?v=10`;  // cache-bust
const APRILTAG_WORKER_URL = '/vendor/apriltag/apriltag.js';
const APRILTAG_WASM_JS    = '/vendor/apriltag/apriltag_wasm.js';
const APRILTAG_WASM_BIN   = '/vendor/apriltag/apriltag_wasm.wasm';

/* ----------- DOM ----------- */
const $ = s => document.querySelector(s);
const statsEl = $('#stats'), msgEl = $('#msg'), pinsEl = $('#pins');
const cam = $('#cam'), work = $('#work');
const wctx = work.getContext('2d', { willReadFrequently: true });

/* ----------- helpers ----------- */
async function loadJSON(url){
  const r = await fetch(url,{cache:'no-store'});
  if(!r.ok) throw new Error(`Config HTTP ${r.status}`);
  const txt = await r.text();
  return JSON.parse(txt.replace(/^\uFEFF/,'').replace(/^\s*\/\/.*$/mg,''));
}
function toGray(rgba,w,h){
  const g = new Uint8Array(w*h);
  for(let i=0,j=0;j<g.length;i+=4,j++) g[j]=(0.299*rgba[i]+0.587*rgba[i+1]+0.114*rgba[i+2])|0;
  return g;
}
async function loadAprilTag(){
  await Promise.all([APRILTAG_WASM_JS, APRILTAG_WASM_BIN].map(p =>
    fetch(p,{cache:'no-store'}).then(r => { if(!r.ok) throw new Error(`Missing: ${p}`); })
  ));
  const worker = new Worker(APRILTAG_WORKER_URL, { type: 'classic' });
  const RemoteApriltag = Comlink.wrap(worker);
  let readyResolve; const ready = new Promise(r => (readyResolve = r));
  const detector = await new RemoteApriltag(Comlink.proxy(() => readyResolve()));
  await ready;
  await detector.set_return_pose(0);
  await detector.set_max_detections(0);
  return detector;
}

/* ----------- homography ----------- */
function computeHomography(world,image){
  const A=[], b=[];
  for(let i=0;i<world.length;i++){
    const [X,Y]=world[i],[u,v]=image[i];
    A.push([X,Y,1, 0,0,0, -u*X,-u*Y]); b.push(u);
    A.push([0,0,0, X,Y,1, -v*X,-v*Y]); b.push(v);
  }
  const n=8, m=A.length, AtA=Array.from({length:n},()=>new Float64Array(n)), Atb=new Float64Array(n);
  for(let r=0;r<m;r++){ const R=A[r], br=b[r]; for(let i=0;i<n;i++){ Atb[i]+=R[i]*br; for(let j=0;j<n;j++) AtA[i][j]+=R[i]*R[j]; } }
  function chol(A,b){ const n=A.length,L=Array.from({length:n},()=>new Float64Array(n));
    for(let i=0;i<n;i++){ for(let j=0;j<=i;j++){ let s=A[i][j]; for(let k=0;k<j;k++) s-=L[i][k]*L[j][k]; L[i][j]=(i===j)?Math.sqrt(Math.max(s,1e-12)):s/L[j][j]; } }
    const y=new Float64Array(n); for(let i=0;i<n;i++){ let s=b[i]; for(let k=0;k<i;k++) s-=L[i][k]*y[k]; y[i]=s/L[i][i]; }
    const x=new Float64Array(n); for(let i=n-1;i>=0;i--){ let s=y[i]; for(let k=i+1;k<n;k++) s-=L[k][i]*x[k]; x[i]=s/L[i][i]; } return x; }
  const h=chol(AtA,Atb);
  return new Float64Array([h[0],h[1],h[2], h[3],h[4],h[5], h[6],h[7], 1]);
}
const applyH=(H,X,Y)=>{const u=H[0]*X+H[1]*Y+H[2], v=H[3]*X+H[4]*Y+H[5], w=H[6]*X+H[7]*Y+H[8]; return [u/w,v/w];};
const smooth=(p,n,a=0.25)=>!p?n:[p[0]*(1-a)+n[0]*a, p[1]*(1-a)+n[1]*a];

/* ----------- detection normalization ----------- */
function normalizeDetections(d){
  if (!d) return [];
  if (typeof d === 'string') { try { d = JSON.parse(d); } catch {} }
  if (Array.isArray(d)) return d;
  for (const k of ['result','results','detections','tags']) {
    if (Array.isArray(d[k])) return d[k];
  }
  if (typeof d === 'object') return Object.values(d);
  return [];
}
const getId = det => det.id ?? det.tag_id ?? det.tagId ?? det.code ?? det.i;
function getCorners(det){
  let c = null;
  if (det.corners) c = det.corners;
  else if (det.c) c = det.c;
  else if (det.p) c = det.p;
  else if (det.lb && det.lt && det.rt && det.rb) c = [det.lt, det.rt, det.rb, det.lb];
  else if (det.tl && det.tr && det.br && det.bl) c = [det.tl, det.tr, det.br, det.bl];
  else if (det.points) c = det.points;
  else if (det.corner || det.corner_pts) c = det.corner || det.corner_pts;
  if (!c && typeof det === 'object' && det['0'] && det['3']) c = [det['0'], det['1'], det['2'], det['3']];
  if (Array.isArray(c) && c.length === 8 && typeof c[0] === 'number') {
    c = [[c[0],c[1]],[c[2],c[3]],[c[4],c[5]],[c[6],c[7]]];
  }
  if (!Array.isArray(c) && typeof c === 'object') c = Object.values(c);
  if (Array.isArray(c) && c.length >= 4) {
    const pts = c.slice(0,4).map(p => {
      if (Array.isArray(p)) return [Number(p[0]), Number(p[1])];
      if (p && typeof p === 'object') return [Number(p.x ?? p.u ?? p[0]), Number(p.y ?? p.v ?? p[1])];
      return [NaN, NaN];
    });
    if (pts.every(q => Number.isFinite(q[0]) && Number.isFinite(q[1]))) return pts;
  }
  return null;
}
const centerOf = corners => {
  const [a,b,c,d] = corners; return [(a[0]+b[0]+c[0]+d[0])/4, (a[1]+b[1]+c[1]+d[1])/4];
};

/* ----------- main ----------- */
let cfg, detector, stream, track;
const tagWorld=[], tagImage=[];
let H=null;
const pinEls=new Map(), pinSmoothed=new Map();
const K_MIN_CENTERS=4;

function updateStats(n){ statsEl.textContent = `${n} tag${n===1?'':'s'}`; }
function logError(e){ const m=(e && (e.stack||e.message)) || String(e); msgEl.textContent=m; console.error(e); }

async function init(){
  cfg = await loadJSON(CFG_URL);

  // ensure at least one demo pin so you see something
  if (!cfg.hotspots || !cfg.hotspots.length) {
    cfg.hotspots = [{ xy_mm: [cfg.map_size_mm[0]/2, cfg.map_size_mm[1]/2], z_mm: 0, label: 'Map center' }];
  }

  detector = await loadAprilTag();

  // Camera
  stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: {ideal:'environment'} } });
  cam.srcObject = stream; await cam.play();
  track = stream.getVideoTracks?.()[0];

  // Torch (best effort)
  try {
    const caps = track?.getCapabilities?.();
    if (caps?.torch) {
      const btn = document.getElementById('torch');
      btn.hidden = false;
      btn.onclick = async () => {
        const st = track.getSettings?.() || {};
        await track.applyConstraints({ advanced: [{ torch: !st.torch }]});
      };
    }
  } catch {}

  // Plenty of pixels (cap ~1280 wide)
  const vw=cam.videoWidth, vh=cam.videoHeight, target=Math.min(1280, vw), sc=target/vw;
  work.width=Math.round(vw*sc); work.height=Math.round(vh*sc);

  // Pins
  for (const h of cfg.hotspots){
    const el=document.createElement('div'); el.className='pin';
    const cap=document.createElement('span'); cap.textContent=h.label||''; el.appendChild(cap);
    pinsEl.appendChild(el); pinEls.set(h,el);
  }

  msgEl.textContent='Aim so 3–4 tags are visible';
  requestAnimationFrame(loop);
}

function gatherCenters(list, sx, sy){
  // Build world/image pairs from tag centers (robust to corner ordering)
  tagWorld.length=0; tagImage.length=0;
  const lut=new Map(cfg.apriltags.map(t=>[t.id,t]));
  for(const d of normalizeDetections(list)){
    const id=getId(d); const t=lut.get(id); if(!t) continue;
    const corners=getCorners(d); if(!corners) continue;
    const [u,v]=centerOf(corners);
    tagWorld.push([t.center_xy_mm[0], t.center_xy_mm[1]]);
    tagImage.push([u/sx, v/sy]);
  }
}
function gatherOneTagCorners(list, sx, sy){
  // Fallback: use the first tag's corners (gives 4 points)
  tagWorld.length=0; tagImage.length=0;
  const lut=new Map(cfg.apriltags.map(t=>[t.id,t]));
  for(const d of normalizeDetections(list)){
    const id=getId(d); const t=lut.get(id); if(!t) continue;
    const corners=getCorners(d); if(!corners) continue;
    const s=t.size_mm/2, wx=t.center_xy_mm[0], wy=t.center_xy_mm[1];
    const world=[[wx-s,wy+s],[wx+s,wy+s],[wx+s,wy-s],[wx-s,wy-s]];
    const image=corners.map(([u,v])=>[u/sx, v/sy]);
    for(let i=0;i<4;i++){ tagWorld.push(world[i]); tagImage.push(image[i]); }
    break; // only first tag needed
  }
}

function layoutPins(){
  if(!H) return;
  const vw=cam.videoWidth, vh=cam.videoHeight;
  for(const h of cfg.hotspots){
    const el=pinEls.get(h); if(!el) continue;
    const [u,v]=applyH(H,h.xy_mm[0],h.xy_mm[1]);
    const sm=smooth(pinSmoothed.get(h),[u,v],0.25);
    pinSmoothed.set(h,sm);
    el.style.left=`${(sm[0]/vw)*100}vw`;
    el.style.top =`${(sm[1]/vh)*100}vh`;
  }
}

async function loop(){
  try{
    wctx.drawImage(cam,0,0,work.width,work.height);
    const frame=wctx.getImageData(0,0,work.width,work.height);
    const gray=toGray(frame.data, work.width, work.height);
    const dets=await detector.detect(gray, work.width, work.height);

    const sx=cam.videoWidth/work.width, sy=cam.videoHeight/work.height;
    // Prefer centers if we have ≥4 tags; else fall back to one tag’s corners
    gatherCenters(dets, sx, sy);
    if (tagWorld.length >= K_MIN_CENTERS) {
      H = computeHomography(tagWorld, tagImage);
    } else {
      gatherOneTagCorners(dets, sx, sy);
      if (tagWorld.length === 4) H = computeHomography(tagWorld, tagImage);
    }

    if (H){
      msgEl.textContent = '';
      layoutPins();
      updateStats(normalizeDetections(dets).length);
    } else {
      msgEl.textContent = 'Move closer until 3–4 tags are visible';
      updateStats(normalizeDetections(dets).length);
    }
  } catch(e){ const m=(e && (e.stack||e.message))||String(e); msgEl.textContent=m; console.error(e); }
  requestAnimationFrame(loop);
}

init().catch(e => { const m=(e && (e.stack||e.message))||String(e); msgEl.textContent=m; console.error(e); });
</script>
</body>
</html>
