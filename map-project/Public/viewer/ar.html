<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="2487.7">
  <style type="text/css">
    p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica}
    p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; min-height: 14.0px}
  </style>
</head>
<body>
<p class="p1">&lt;!doctype html&gt;</p>
<p class="p1">&lt;html lang="en"&gt;</p>
<p class="p1">&lt;head&gt;</p>
<p class="p1">&lt;meta charset="utf-8"/&gt;</p>
<p class="p1">&lt;meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/&gt;</p>
<p class="p1">&lt;title&gt;Wood Map AR&lt;/title&gt;</p>
<p class="p1">&lt;style&gt;</p>
<p class="p1"><span class="Apple-converted-space">  </span>:root { color-scheme: dark; }</p>
<p class="p1"><span class="Apple-converted-space">  </span>html,body{margin:0;height:100%;background:#0b0d10;color:#e7eaee;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}</p>
<p class="p1"><span class="Apple-converted-space">  </span>#hud{position:fixed;inset:0;pointer-events:none}</p>
<p class="p1"><span class="Apple-converted-space">  </span>#stats{position:fixed;left:10px;bottom:10px;background:#1118;padding:8px 10px;border:1px solid #1b2028;border-radius:10px;font-size:12px}</p>
<p class="p1"><span class="Apple-converted-space">  </span>#msg{position:fixed;top:10px;left:50%;transform:translateX(-50%);background:#1118;padding:8px 10px;border:1px solid #1b2028;border-radius:10px;font-size:12px}</p>
<p class="p1"><span class="Apple-converted-space">  </span>#pins{position:absolute;inset:0;pointer-events:none}</p>
<p class="p1"><span class="Apple-converted-space">  </span>.pin{position:absolute;transform:translate(-50%,-100%);padding:4px 6px;border-radius:10px;border:1px solid #1b2028;background:#141a22cc;backdrop-filter:blur(3px);pointer-events:auto}</p>
<p class="p1"><span class="Apple-converted-space">  </span>.pin img{display:block;max-width:160px;max-height:100px;border-radius:8px;margin-bottom:4px}</p>
<p class="p1"><span class="Apple-converted-space">  </span>.pin span{font-size:12px}</p>
<p class="p1"><span class="Apple-converted-space">  </span>video{position:fixed;inset:0;object-fit:cover;width:100%;height:100%}</p>
<p class="p1"><span class="Apple-converted-space">  </span>canvas{display:none}</p>
<p class="p1"><span class="Apple-converted-space">  </span>button#torch{position:fixed;right:10px;bottom:10px;z-index:10}</p>
<p class="p1">&lt;/style&gt;</p>
<p class="p1">&lt;/head&gt;</p>
<p class="p1">&lt;body&gt;</p>
<p class="p1">&lt;video id="cam" playsinline autoplay muted&gt;&lt;/video&gt;</p>
<p class="p1">&lt;canvas id="work"&gt;&lt;/canvas&gt;</p>
<p class="p1">&lt;div id="hud"&gt;</p>
<p class="p1"><span class="Apple-converted-space">  </span>&lt;div id="pins"&gt;&lt;/div&gt;</p>
<p class="p1"><span class="Apple-converted-space">  </span>&lt;div id="msg"&gt;Allow camera. Aim so 3–4 tags are visible.&lt;/div&gt;</p>
<p class="p1"><span class="Apple-converted-space">  </span>&lt;div id="stats"&gt;init…&lt;/div&gt;</p>
<p class="p1">&lt;/div&gt;</p>
<p class="p1">&lt;button id="torch" hidden&gt;Torch&lt;/button&gt;</p>
<p class="p2"><br></p>
<p class="p1">&lt;script type="module"&gt;</p>
<p class="p1">/* ---------- config ---------- */</p>
<p class="p1">const params = new URLSearchParams(location.search);</p>
<p class="p1">const id = params.get('id') || 'valdez-001';</p>
<p class="p1">const CFG_URL = `/data/${id}.json`;</p>
<p class="p2"><br></p>
<p class="p1">// Change these if you put the WASM elsewhere:</p>
<p class="p1">const APRILTAG_JS <span class="Apple-converted-space">  </span>= '/vendor/apriltag/apriltag.js';</p>
<p class="p1">const APRILTAG_WASM = '/vendor/apriltag/apriltag_wasm.wasm';</p>
<p class="p2"><br></p>
<p class="p1">// Detection resolution (work canvas width). Higher = better but slower.</p>
<p class="p1">const DETECT_W = 640;</p>
<p class="p2"><br></p>
<p class="p1">/* ---------- utils ---------- */</p>
<p class="p1">const $ = sel =&gt; document.querySelector(sel);</p>
<p class="p1">const statsEl = $('#stats'), msgEl = $('#msg'), pinsEl = $('#pins');</p>
<p class="p1">const cam = $('#cam'), work = $('#work'); const wctx = work.getContext('2d', { willReadFrequently: true });</p>
<p class="p2"><br></p>
<p class="p1">function now(){ return performance.now(); }</p>
<p class="p2"><br></p>
<p class="p1">// Compute homography H (3x3) from world points (x,y) on Z=0 to image points (u,v).</p>
<p class="p1">// Uses DLT with least-squares (&gt;=4 points). Returns Float64Array(9) row-major.</p>
<p class="p1">function computeHomography(world, image){</p>
<p class="p1"><span class="Apple-converted-space">  </span>// Build A * h = 0</p>
<p class="p1"><span class="Apple-converted-space">  </span>const n = world.length;</p>
<p class="p1"><span class="Apple-converted-space">  </span>const A = new Float64Array(n*2*9); // we’ll solve via SVD w/ numeric.js-ish manual? Simpler: use linear least squares with 8 unknowns (h normalized)</p>
<p class="p1"><span class="Apple-converted-space">  </span>// Implement classic DLT: for each correspondence (X,Y) -&gt; (u,v)</p>
<p class="p1"><span class="Apple-converted-space">  </span>const rows = [];</p>
<p class="p1"><span class="Apple-converted-space">  </span>for (let i=0;i&lt;n;i++){</p>
<p class="p1"><span class="Apple-converted-space">    </span>const [X,Y]=world[i], [u,v]=image[i];</p>
<p class="p1"><span class="Apple-converted-space">    </span>rows.push([-X,-Y,-1, 0, 0, 0, u*X, u*Y, u]);</p>
<p class="p1"><span class="Apple-converted-space">    </span>rows.push([0, 0, 0,-X,-Y,-1, v*X, v*Y, v]);</p>
<p class="p1"><span class="Apple-converted-space">  </span>}</p>
<p class="p1"><span class="Apple-converted-space">  </span>// Solve Ah = 0 via SVD. To avoid shipping an SVD, use numeric eigen on A^T A.</p>
<p class="p1"><span class="Apple-converted-space">  </span>const m = rows.length, k = 9;</p>
<p class="p1"><span class="Apple-converted-space">  </span>const ATA = Array.from({length:k},()=&gt;new Float64Array(k));</p>
<p class="p1"><span class="Apple-converted-space">  </span>for(let r=0;r&lt;m;r++){</p>
<p class="p1"><span class="Apple-converted-space">    </span>const row = rows[r];</p>
<p class="p1"><span class="Apple-converted-space">    </span>for(let i=0;i&lt;k;i++){</p>
<p class="p1"><span class="Apple-converted-space">      </span>const ri = row[i];</p>
<p class="p1"><span class="Apple-converted-space">      </span>for(let j=0;j&lt;k;j++){</p>
<p class="p1"><span class="Apple-converted-space">        </span>ATA[i][j] += ri*row[j];</p>
<p class="p1"><span class="Apple-converted-space">      </span>}</p>
<p class="p1"><span class="Apple-converted-space">    </span>}</p>
<p class="p1"><span class="Apple-converted-space">  </span>}</p>
<p class="p1"><span class="Apple-converted-space">  </span>// Power iteration for smallest eigenvector is messy; instead use naive Jacobi? For simplicity and stability here:</p>
<p class="p1"><span class="Apple-converted-space">  </span>// Use a tiny imported SVD/eigen. To keep this file single-file, we do a minimal numeric eigen via library-free approach is too long.</p>
<p class="p1"><span class="Apple-converted-space">  </span>// So we’ll reduce the unknowns to 8 by fixing h[8]=1 and solve least squares: A8 * h8 = b</p>
<p class="p1"><span class="Apple-converted-space">  </span>// Rebuild A8,b using standard formulation:</p>
<p class="p1"><span class="Apple-converted-space">  </span>const A8=[]; const b8=[];</p>
<p class="p1"><span class="Apple-converted-space">  </span>for (let i=0;i&lt;n;i++){</p>
<p class="p1"><span class="Apple-converted-space">    </span>const [X,Y]=world[i], [u,v]=image[i];</p>
<p class="p1"><span class="Apple-converted-space">    </span>A8.push([X,Y,1, 0,0,0, -u*X, -u*Y]); b8.push(u);</p>
<p class="p1"><span class="Apple-converted-space">    </span>A8.push([0,0,0, X,Y,1, -v*X, -v*Y]); b8.push(v);</p>
<p class="p1"><span class="Apple-converted-space">  </span>}</p>
<p class="p1"><span class="Apple-converted-space">  </span>// Solve normal equations (A8^T A8) h8 = A8^T b8</p>
<p class="p1"><span class="Apple-converted-space">  </span>const rows8=A8.length, cols8=8;</p>
<p class="p1"><span class="Apple-converted-space">  </span>const AtA = Array.from({length:cols8},()=&gt;new Float64Array(cols8));</p>
<p class="p1"><span class="Apple-converted-space">  </span>const Atb = new Float64Array(cols8);</p>
<p class="p1"><span class="Apple-converted-space">  </span>for(let r=0;r&lt;rows8;r++){</p>
<p class="p1"><span class="Apple-converted-space">    </span>const row=A8[r], br=b8[r];</p>
<p class="p1"><span class="Apple-converted-space">    </span>for(let i=0;i&lt;cols8;i++){</p>
<p class="p1"><span class="Apple-converted-space">      </span>Atb[i]+=row[i]*br;</p>
<p class="p1"><span class="Apple-converted-space">      </span>for(let j=0;j&lt;cols8;j++){</p>
<p class="p1"><span class="Apple-converted-space">        </span>AtA[i][j]+=row[i]*row[j];</p>
<p class="p1"><span class="Apple-converted-space">      </span>}</p>
<p class="p1"><span class="Apple-converted-space">    </span>}</p>
<p class="p1"><span class="Apple-converted-space">  </span>}</p>
<p class="p1"><span class="Apple-converted-space">  </span>// Cholesky solve AtA * x = Atb</p>
<p class="p1"><span class="Apple-converted-space">  </span>function choleskySolve(A,b){</p>
<p class="p1"><span class="Apple-converted-space">    </span>const n=A.length;</p>
<p class="p1"><span class="Apple-converted-space">    </span>const L=Array.from({length:n},()=&gt;new Float64Array(n));</p>
<p class="p1"><span class="Apple-converted-space">    </span>for(let i=0;i&lt;n;i++){</p>
<p class="p1"><span class="Apple-converted-space">      </span>for(let j=0;j&lt;=i;j++){</p>
<p class="p1"><span class="Apple-converted-space">        </span>let s=A[i][j];</p>
<p class="p1"><span class="Apple-converted-space">        </span>for(let k=0;k&lt;j;k++) s-=L[i][k]*L[j][k];</p>
<p class="p1"><span class="Apple-converted-space">        </span>if(i===j){ L[i][j]=Math.sqrt(Math.max(s,1e-12)); }</p>
<p class="p1"><span class="Apple-converted-space">        </span>else { L[i][j]=s/L[j][j]; }</p>
<p class="p1"><span class="Apple-converted-space">      </span>}</p>
<p class="p1"><span class="Apple-converted-space">    </span>}</p>
<p class="p1"><span class="Apple-converted-space">    </span>// Ly=b</p>
<p class="p1"><span class="Apple-converted-space">    </span>const y=new Float64Array(n);</p>
<p class="p1"><span class="Apple-converted-space">    </span>for(let i=0;i&lt;n;i++){</p>
<p class="p1"><span class="Apple-converted-space">      </span>let s=b[i];</p>
<p class="p1"><span class="Apple-converted-space">      </span>for(let k=0;k&lt;i;k++) s-=L[i][k]*y[k];</p>
<p class="p1"><span class="Apple-converted-space">      </span>y[i]=s/L[i][i];</p>
<p class="p1"><span class="Apple-converted-space">    </span>}</p>
<p class="p1"><span class="Apple-converted-space">    </span>// L^T x = y</p>
<p class="p1"><span class="Apple-converted-space">    </span>const x=new Float64Array(n);</p>
<p class="p1"><span class="Apple-converted-space">    </span>for(let i=n-1;i&gt;=0;i--){</p>
<p class="p1"><span class="Apple-converted-space">      </span>let s=y[i];</p>
<p class="p1"><span class="Apple-converted-space">      </span>for(let k=i+1;k&lt;n;k++) s-=L[k][i]*x[k];</p>
<p class="p1"><span class="Apple-converted-space">      </span>x[i]=s/L[i][i];</p>
<p class="p1"><span class="Apple-converted-space">    </span>}</p>
<p class="p1"><span class="Apple-converted-space">    </span>return x;</p>
<p class="p1"><span class="Apple-converted-space">  </span>}</p>
<p class="p1"><span class="Apple-converted-space">  </span>const h8 = choleskySolve(AtA, Atb);</p>
<p class="p1"><span class="Apple-converted-space">  </span>const H = new Float64Array([</p>
<p class="p1"><span class="Apple-converted-space">    </span>h8[0], h8[1], h8[2],</p>
<p class="p1"><span class="Apple-converted-space">    </span>h8[3], h8[4], h8[5],</p>
<p class="p1"><span class="Apple-converted-space">    </span>h8[6], h8[7], 1</p>
<p class="p1"><span class="Apple-converted-space">  </span>]);</p>
<p class="p1"><span class="Apple-converted-space">  </span>return H;</p>
<p class="p1">}</p>
<p class="p2"><br></p>
<p class="p1">// Apply homography to a point (X,Y) -&gt; (u,v)</p>
<p class="p1">function applyH(H, X, Y){</p>
<p class="p1"><span class="Apple-converted-space">  </span>const u = H[0]*X + H[1]*Y + H[2];</p>
<p class="p1"><span class="Apple-converted-space">  </span>const v = H[3]*X + H[4]*Y + H[5];</p>
<p class="p1"><span class="Apple-converted-space">  </span>const w = H[6]*X + H[7]*Y + H[8];</p>
<p class="p1"><span class="Apple-converted-space">  </span>return [u/w, v/w];</p>
<p class="p1">}</p>
<p class="p2"><br></p>
<p class="p1">// Simple EMA smoother for 2D points</p>
<p class="p1">function smooth(prev, next, a=0.2){</p>
<p class="p1"><span class="Apple-converted-space">  </span>if(!prev) return next;</p>
<p class="p1"><span class="Apple-converted-space">  </span>return [prev[0]*(1-a)+next[0]*a, prev[1]*(1-a)+next[1]*a];</p>
<p class="p1">}</p>
<p class="p2"><br></p>
<p class="p1">/* ---------- main ---------- */</p>
<p class="p1">let cfg, detector, videoStream, track;</p>
<p class="p1">let lastT = 0, fps = 0;</p>
<p class="p1">const K_MIN_POINTS = 4; // need at least 4 correspondences</p>
<p class="p2"><br></p>
<p class="p1">const tagWorldPoints = []; <span class="Apple-converted-space">  </span>// per-frame subset of world points</p>
<p class="p1">const tagImagePoints = []; <span class="Apple-converted-space">  </span>// per-frame subset of image points</p>
<p class="p1">let H = null;<span class="Apple-converted-space">                </span>// current homography</p>
<p class="p1">const pinEls = new Map();<span class="Apple-converted-space">    </span>// hotspot -&gt; element</p>
<p class="p1">const pinSmoothed = new Map();</p>
<p class="p2"><br></p>
<p class="p1">async function init(){</p>
<p class="p1"><span class="Apple-converted-space">  </span>cfg = await (await fetch(CFG_URL, {cache:'no-store'})).json();</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">  </span>// Load WASM detector (self-hosted)</p>
<p class="p1"><span class="Apple-converted-space">  </span>const mod = await import(APRILTAG_JS);</p>
<p class="p1"><span class="Apple-converted-space">  </span>detector = await mod.default({ locateFile:(p)=&gt; p.endsWith('.wasm') ? APRILTAG_WASM : p });</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">  </span>// Camera</p>
<p class="p1"><span class="Apple-converted-space">  </span>const constraints = { video: { facingMode: 'environment' } };</p>
<p class="p1"><span class="Apple-converted-space">  </span>videoStream = await navigator.mediaDevices.getUserMedia(constraints);</p>
<p class="p1"><span class="Apple-converted-space">  </span>cam.srcObject = videoStream;</p>
<p class="p1"><span class="Apple-converted-space">  </span>await cam.play();</p>
<p class="p1"><span class="Apple-converted-space">  </span>track = videoStream.getVideoTracks()[0];</p>
<p class="p1"><span class="Apple-converted-space">  </span>try {</p>
<p class="p1"><span class="Apple-converted-space">    </span>const caps = track.getCapabilities?.();</p>
<p class="p1"><span class="Apple-converted-space">    </span>if (caps?.torch) $('#torch').hidden = false;</p>
<p class="p1"><span class="Apple-converted-space">    </span>$('#torch').onclick = async () =&gt; {</p>
<p class="p1"><span class="Apple-converted-space">      </span>const st = track.getSettings();</p>
<p class="p1"><span class="Apple-converted-space">      </span>await track.applyConstraints({ advanced: [{ torch: !st.torch }]});</p>
<p class="p1"><span class="Apple-converted-space">    </span>};</p>
<p class="p1"><span class="Apple-converted-space">  </span>} catch {}</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">  </span>// Work canvas sizing</p>
<p class="p1"><span class="Apple-converted-space">  </span>const vw = cam.videoWidth, vh = cam.videoHeight;</p>
<p class="p1"><span class="Apple-converted-space">  </span>const scale = DETECT_W / vw;</p>
<p class="p1"><span class="Apple-converted-space">  </span>work.width = DETECT_W;</p>
<p class="p1"><span class="Apple-converted-space">  </span>work.height = Math.round(vh * scale);</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">  </span>// Build pin DOMs</p>
<p class="p1"><span class="Apple-converted-space">  </span>for (const h of cfg.hotspots){</p>
<p class="p1"><span class="Apple-converted-space">    </span>const el = document.createElement('div');</p>
<p class="p1"><span class="Apple-converted-space">    </span>el.className = 'pin';</p>
<p class="p1"><span class="Apple-converted-space">    </span>if (h.img){</p>
<p class="p1"><span class="Apple-converted-space">      </span>const img = document.createElement('img'); img.src = h.img; el.appendChild(img);</p>
<p class="p1"><span class="Apple-converted-space">    </span>}</p>
<p class="p1"><span class="Apple-converted-space">    </span>const cap = document.createElement('span'); cap.textContent = h.label || '';</p>
<p class="p1"><span class="Apple-converted-space">    </span>el.appendChild(cap);</p>
<p class="p1"><span class="Apple-converted-space">    </span>pinsEl.appendChild(el);</p>
<p class="p1"><span class="Apple-converted-space">    </span>pinEls.set(h, el);</p>
<p class="p1"><span class="Apple-converted-space">  </span>}</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">  </span>msgEl.textContent = 'Align so 3–4 tags are in view';</p>
<p class="p1"><span class="Apple-converted-space">  </span>requestAnimationFrame(loop);</p>
<p class="p1">}</p>
<p class="p2"><br></p>
<p class="p1">function gatherCorrespondences(dets, sx, sy){</p>
<p class="p1"><span class="Apple-converted-space">  </span>tagWorldPoints.length = 0; tagImagePoints.length = 0;</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">  </span>// Build a lookup by id -&gt; world corner coords in mm (relative to map origin)</p>
<p class="p1"><span class="Apple-converted-space">  </span>const byId = new Map(cfg.apriltags.map(t =&gt; [t.id, t]));</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">  </span>for (const d of dets){</p>
<p class="p1"><span class="Apple-converted-space">    </span>const t = byId.get(d.id);</p>
<p class="p1"><span class="Apple-converted-space">    </span>if (!t) continue;</p>
<p class="p1"><span class="Apple-converted-space">    </span>// world corners (clockwise) from center &amp; size</p>
<p class="p1"><span class="Apple-converted-space">    </span>const s = t.size_mm/2;</p>
<p class="p1"><span class="Apple-converted-space">    </span>const wx = t.center_xy_mm[0], wy = t.center_xy_mm[1];</p>
<p class="p1"><span class="Apple-converted-space">    </span>const worldCorners = [</p>
<p class="p1"><span class="Apple-converted-space">      </span>[wx - s, wy + s], // top-left</p>
<p class="p1"><span class="Apple-converted-space">      </span>[wx + s, wy + s], // top-right</p>
<p class="p1"><span class="Apple-converted-space">      </span>[wx + s, wy - s], // bottom-right</p>
<p class="p1"><span class="Apple-converted-space">      </span>[wx - s, wy - s]<span class="Apple-converted-space">  </span>// bottom-left</p>
<p class="p1"><span class="Apple-converted-space">    </span>];</p>
<p class="p1"><span class="Apple-converted-space">    </span>// image corners from detector (already ordered TL,TR,BR,BL typically)</p>
<p class="p1"><span class="Apple-converted-space">    </span>const imgCorners = d.corners.map(([u,v]) =&gt; [u/sx, v/sy]); // rescale to full video coords</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">    </span>for (let i=0;i&lt;4;i++){</p>
<p class="p1"><span class="Apple-converted-space">      </span>tagWorldPoints.push(worldCorners[i]);</p>
<p class="p1"><span class="Apple-converted-space">      </span>tagImagePoints.push(imgCorners[i]);</p>
<p class="p1"><span class="Apple-converted-space">    </span>}</p>
<p class="p1"><span class="Apple-converted-space">  </span>}</p>
<p class="p1">}</p>
<p class="p2"><br></p>
<p class="p1">function layoutPins(){</p>
<p class="p1"><span class="Apple-converted-space">  </span>if (!H) return;</p>
<p class="p1"><span class="Apple-converted-space">  </span>const vw = cam.videoWidth, vh = cam.videoHeight;</p>
<p class="p1"><span class="Apple-converted-space">  </span>for (const h of cfg.hotspots){</p>
<p class="p1"><span class="Apple-converted-space">    </span>const el = pinEls.get(h);</p>
<p class="p1"><span class="Apple-converted-space">    </span>const [u, v] = applyH(H, h.xy_mm[0], h.xy_mm[1]);</p>
<p class="p1"><span class="Apple-converted-space">    </span>// smooth</p>
<p class="p1"><span class="Apple-converted-space">    </span>const sm = smooth(pinSmoothed.get(h), [u, v], 0.25);</p>
<p class="p1"><span class="Apple-converted-space">    </span>pinSmoothed.set(h, sm);</p>
<p class="p1"><span class="Apple-converted-space">    </span>// place in screen CSS pixels</p>
<p class="p1"><span class="Apple-converted-space">    </span>el.style.left = `${(sm[0] / vw) * 100}vw`;</p>
<p class="p1"><span class="Apple-converted-space">    </span>el.style.top<span class="Apple-converted-space">  </span>= `${(sm[1] / vh) * 100}vh`;</p>
<p class="p1"><span class="Apple-converted-space">  </span>}</p>
<p class="p1">}</p>
<p class="p2"><br></p>
<p class="p1">function updateStats(nTags){</p>
<p class="p1"><span class="Apple-converted-space">  </span>statsEl.textContent = `${nTags} tag${nTags===1?'':'s'} · ${fps.toFixed(0)} fps`;</p>
<p class="p1">}</p>
<p class="p2"><br></p>
<p class="p1">async function loop(t){</p>
<p class="p1"><span class="Apple-converted-space">  </span>const dt = t - lastT; lastT = t; fps = 1000/(dt||1000);</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">  </span>// Draw frame to work canvas (downscaled)</p>
<p class="p1"><span class="Apple-converted-space">  </span>wctx.drawImage(cam, 0, 0, work.width, work.height);</p>
<p class="p1"><span class="Apple-converted-space">  </span>const imgData = wctx.getImageData(0, 0, work.width, work.height);</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">  </span>// Detect</p>
<p class="p1"><span class="Apple-converted-space">  </span>const dets = detector.detect(imgData.data, work.width, work.height);</p>
<p class="p1"><span class="Apple-converted-space">  </span>// det: { id: number, corners: [[u,v]x4] } in work-canvas coords</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">  </span>// Compute homography if we have enough correspondences</p>
<p class="p1"><span class="Apple-converted-space">  </span>const sx = cam.videoWidth / work.width;</p>
<p class="p1"><span class="Apple-converted-space">  </span>const sy = cam.videoHeight / work.height;</p>
<p class="p1"><span class="Apple-converted-space">  </span>gatherCorrespondences(dets, sx, sy);</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">  </span>if (tagWorldPoints.length &gt;= K_MIN_POINTS){</p>
<p class="p1"><span class="Apple-converted-space">    </span>try {</p>
<p class="p1"><span class="Apple-converted-space">      </span>H = computeHomography(tagWorldPoints, tagImagePoints);</p>
<p class="p1"><span class="Apple-converted-space">      </span>msgEl.textContent = '';</p>
<p class="p1"><span class="Apple-converted-space">      </span>layoutPins();</p>
<p class="p1"><span class="Apple-converted-space">      </span>updateStats(dets.length);</p>
<p class="p1"><span class="Apple-converted-space">    </span>} catch (e){</p>
<p class="p1"><span class="Apple-converted-space">      </span>// keep previous H if solve fails</p>
<p class="p1"><span class="Apple-converted-space">      </span>updateStats(dets.length);</p>
<p class="p1"><span class="Apple-converted-space">    </span>}</p>
<p class="p1"><span class="Apple-converted-space">  </span>} else {</p>
<p class="p1"><span class="Apple-converted-space">    </span>msgEl.textContent = 'Move closer until 3–4 tags are visible';</p>
<p class="p1"><span class="Apple-converted-space">    </span>updateStats(dets.length);</p>
<p class="p1"><span class="Apple-converted-space">  </span>}</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">  </span>requestAnimationFrame(loop);</p>
<p class="p1">}</p>
<p class="p2"><br></p>
<p class="p1">init().catch(err =&gt; {</p>
<p class="p1"><span class="Apple-converted-space">  </span>msgEl.textContent = err.message;</p>
<p class="p1"><span class="Apple-converted-space">  </span>console.error(err);</p>
<p class="p1">});</p>
<p class="p1">&lt;/script&gt;</p>
<p class="p1">&lt;/body&gt;</p>
<p class="p1">&lt;/html&gt;</p>
</body>
</html>
